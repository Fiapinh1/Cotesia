<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Criar Linhas Paralelas dentro de Polígono (KML)</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <style>
      :root {
        --bg: #0f172a; --panel: #111827; --soft: #1f2937; --text: #e5e7eb;
        --muted: #9ca3af; --accent: #60a5fa; --danger: #ef4444;
      }
      html, body { margin: 0; padding: 0; height: 100%; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif; background: var(--bg); color: var(--text); }
      .wrap { max-width: 1000px; margin: 24px auto; padding: 0 16px; }
      .card { background: var(--panel); border: 1px solid #1f2937; border-radius: 10px; padding: 20px; }
      h1 { font-size: 1.4rem; margin: 0 0 12px; }
      p.helper { color: var(--muted); margin-top: 4px; font-size: .95rem; }
      .row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-top: 12px; }
      .row.single { grid-template-columns: 1fr; }
      .field { display: flex; flex-direction: column; gap: 6px; }
      label { color: var(--muted); font-size: .9rem; }
      input[type="number"], input[type="text"], input[type="file"], input[type="range"], select { border: 1px solid #374151; background: var(--soft); color: var(--text); border-radius: 8px; padding: 10px; font-size: 1rem; }
      input[type="range"] { padding: 6px 0; }
      button { background: var(--accent); color: #0b1220; border: none; padding: 10px 14px; border-radius: 8px; font-weight: 600; cursor: pointer; }
      button.secondary { background: #374151; color: var(--text); }
      button:disabled { opacity: .6; cursor: not-allowed; }
      .actions { display: flex; gap: 10px; align-items: center; margin-top: 16px; flex-wrap: wrap; }
      .log { margin-top: 16px; background: #0b1220; border: 1px solid #1f2937; padding: 12px; border-radius: 8px; white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: .9rem; color: #cbd5e1; }
      .success { color: #22c55e; }
      .error { color: var(--danger); }
      .hint { color: var(--muted); font-size: .9rem; }
      .footer { margin-top: 24px; color: var(--muted); font-size: .85rem; text-align: center; }
      a { color: #93c5fd; }
      #map { height: 62vh; width: 100%; margin-top: 16px; border-radius: 10px; border: 1px solid #1f2937; }
      .angle-value { min-width: 60px; text-align: right; }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="card">
        <h1>Criar Linhas Paralelas dentro de Polígono (KML)</h1>
        <p class="helper">Carregue um KML com a área demarcada (<code>&lt;Polygon&gt;</code>). Ajuste espaçamento entre linhas (m), ângulo (°) e altitude (m). Gere linhas paralelas "indo e voltando" dentro do polígono e exporte em KML. Base de satélite incluída para melhor visualização.</p>

        <div class="row single">
          <div class="field">
            <label for="kmlFile">Arquivo KML com Talhões (Polígonos)</label>
            <input id="kmlFile" type="file" accept=".kml,application/vnd.google-earth.kml+xml" />
            <div class="hint">O arquivo pode conter vários <code>&lt;Polygon&gt;</code>. Clique no talhão desejado no mapa para selecioná-lo.</div>
          </div>
        </div>

        <div class="row">
          <div class="field">
            <label for="espacamento">Espaçamento entre linhas (m)</label>
            <input id="espacamento" type="number" min="1" step="1" value="40" />
          </div>
          <div class="field">
            <label for="angulo">Ângulo das linhas (°)</label>
            <div style="display:flex; align-items:center; gap:10px;">
              <input id="angulo" type="range" min="0" max="179" step="1" value="0" style="flex:1;" />
              <input id="anguloBox" type="number" min="0" max="179" step="1" value="0" class="angle-value" />
            </div>
            <div class="hint">0° = Leste-Oeste; aumenta no sentido anti-horário.</div>
          </div>
        </div>

        <div class="row">
          <div class="field">
            <label for="altura">Altitude das linhas (m)</label>
            <input id="altura" type="number" min="0" step="1" value="30" />
          </div>
          <div class="field">
            <label for="nomePrefixo">Prefixo do nome (opcional)</label>
            <input id="nomePrefixo" type="text" placeholder="Ex.: FAIXA-" />
          </div>
        </div>

        <div class="row single">
          <div class="field">
            <label for="bordadura">Bordadura interna (m)</label>
            <input id="bordadura" type="number" min="0" step="1" value="0" />
          </div>
        </div>

        <div class="row">
          <div class="field">
            <label class="checkbox" style="gap:10px; align-items:center;">
              <input id="habilitarPontos" type="checkbox" />
              Adicionar pontos ao longo do caminho
            </label>
          </div>
          <div class="field">
            <label for="espPontos">Espaçamento entre pontos (m)</label>
            <input id="espPontos" type="number" min="1" step="1" value="30" />
          </div>
        </div>

        <div class="actions">
          <button id="btnGerar" disabled>Gerar Linhas</button>
          <a id="downloadLink" class="secondary" href="#" download style="display:none;">Exportar Projeto (KML)</a>
          <a id="downloadPtsLink" class="secondary" href="#" download style="display:none;">Exportar Pontos (KML)</a>
          <button id="btnAnglePick" class="secondary" title="Clique em dois pontos no mapa para definir o ângulo">Definir Ângulo no Mapa</button>
          <button id="btnExemplo" class="secondary" title="Carrega um polígono de exemplo">Carregar Exemplo</button>
          <button id="btnLimpar" class="secondary">Limpar Linhas</button>
          <button id="btnProximo" class="secondary" title="Seleciona o próximo talhão" disabled>Próximo Talhão</button>
        </div>

        <div id="map"></div>
        <div id="log" class="log hint">Carregue um KML de polígono para começar.</div>
      </div>
      <div class="footer">Base satélite: Esri World Imagery • Mapas por Leaflet</div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script>
      // Estado global simples
      let polygonCoords = null; // Array [{lat,lon}] do outer ring (selecionado)
      let polygons = []; // Lista de talhões [{coords, name}]
      let selectedIdx = -1;
      let polyLayer = null; // LayerGroup com todos os talhões
      let linesLayer = null;
      let pointsLayer = null; // Pré-visualização de pontos
      let projectLayer = null; // Linhas acumuladas do projeto
      let projectPaths = [];
      let btnLimparProjetoRef = null; // criado dinamicamente
      let map = null;

      // Helpers de UI
      const logEl = document.getElementById('log');
      const kmlFileEl = document.getElementById('kmlFile');
      const espEl = document.getElementById('espacamento');
      const angEl = document.getElementById('angulo');
      const angBoxEl = document.getElementById('anguloBox');
      const altEl = document.getElementById('altura');
      const borderEl = document.getElementById('bordadura');
      const ptsToggleEl = document.getElementById('habilitarPontos');
      const ptsSpacingEl = document.getElementById('espPontos');
      const namePrefixEl = document.getElementById('nomePrefixo');
      const btnGerar = document.getElementById('btnGerar');
      const dlEl = document.getElementById('downloadLink');
      const dlPtsEl = document.getElementById('downloadPtsLink');
      const btnAnglePick = document.getElementById('btnAnglePick');
      const btnExemplo = document.getElementById('btnExemplo');
      const btnLimpar = document.getElementById('btnLimpar');
      const btnProximo = document.getElementById('btnProximo');
      // Botão 'Limpar Projeto' será criado dinamicamente

      function logMsg(msg, type='hint') {
        logEl.className = 'log ' + (type === 'error' ? 'error' : type === 'success' ? 'success' : 'hint');
        logEl.textContent = msg;
      }

      // Inicializa mapa com base de satélite
      function initMap() {
        map = L.map('map', { zoomControl: true }).setView([-15.78, -47.93], 5); // Brasil
        const esriSat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
          maxZoom: 20,
          attribution: 'Tiles \u00a9 Esri'
        }).addTo(map);
        const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: 'OSM' });
        L.control.layers({ 'Satélite (Esri)': esriSat, 'Ruas (OSM)': osm }).addTo(map);
        polyLayer = L.layerGroup().addTo(map);
        projectLayer = L.layerGroup().addTo(map);
        linesLayer = L.layerGroup().addTo(map);
        pointsLayer = L.layerGroup().addTo(map);
        angleGuideLayer = L.layerGroup().addTo(map);
      }

      initMap();
      createProjectControls();

      // Sincroniza slider/box de ângulo
      angEl.addEventListener('input', () => { angBoxEl.value = angEl.value; updatePreview(); });
      angBoxEl.addEventListener('input', () => {
        let v = parseInt(angBoxEl.value || '0', 10);
        if (!Number.isFinite(v)) v = 0;
        if (v < 0) v = 0; if (v > 179) v = 179;
        angBoxEl.value = v; angEl.value = v; updatePreview();
      });
      // Atualiza pré-visualização ao mudar espaçamento e bordadura
      espEl.addEventListener('input', () => { updatePreview(); });
      borderEl.addEventListener('input', () => { updatePreview(); });
      // Atualiza quando alterna pontos e quando muda espaçamento de pontos
      ptsToggleEl.addEventListener('change', () => { updatePreview(); });
      ptsSpacingEl.addEventListener('input', () => { updatePreview(); });

      // Leitura e parse de KML (múltiplos polígonos)
      kmlFileEl.addEventListener('change', async (e) => {
        const f = e.target.files && e.target.files[0];
        if (!f) return;
        const text = await f.text();
        const res = extractPolygons(text);
        if (!res || res.length === 0) { logMsg('Nenhum polígono válido encontrado no KML.', 'error'); btnGerar.disabled = true; btnProximo.disabled = true; return; }
        polygons = res; selectedIdx = -1; polygonCoords = null; btnGerar.disabled = true; btnProximo.disabled = (polygons.length <= 1); dlEl.style.display = 'none'; dlPtsEl.style.display = 'none';
        drawAllPolygons(polygons);
        const totalVerts = polygons.reduce((s,p)=>s+p.coords.length,0);
        logMsg(`Carregados ${polygons.length} talhão(ões), ${totalVerts} vértices no total. Clique em um talhão para selecionar.`);
      });

      btnExemplo.addEventListener('click', () => {
        const sample = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <Placemark>
      <name>Talhão 01</name>
      <Polygon>
        <outerBoundaryIs>
          <LinearRing>
            <coordinates>
              -47.9400,-15.8100,0 -47.9000,-15.8100,0 -47.9000,-15.7800,0 -47.9400,-15.7800,0 -47.9400,-15.8100,0
            </coordinates>
          </LinearRing>
        </outerBoundaryIs>
      </Polygon>
    </Placemark>
    <Placemark>
      <name>Talhão 02</name>
      <Polygon>
        <outerBoundaryIs>
          <LinearRing>
            <coordinates>
              -47.9850,-15.8150,0 -47.9550,-15.8150,0 -47.9550,-15.7900,0 -47.9850,-15.7900,0 -47.9850,-15.8150,0
            </coordinates>
          </LinearRing>
        </outerBoundaryIs>
      </Polygon>
    </Placemark>
  </Document>
</kml>`;
        polygons = extractPolygons(sample);
        selectedIdx = -1; polygonCoords = null; btnGerar.disabled = true; btnProximo.disabled = (polygons.length <= 1); dlEl.style.display = 'none'; dlPtsEl.style.display = 'none';
        drawAllPolygons(polygons);
        const bounds = L.latLngBounds(polygons.flatMap(pg => pg.coords.map(p => [p.lat, p.lon])));
        map.fitBounds(bounds.pad(0.2));
        logMsg('Exemplo com 2 talhões carregado. Clique para selecionar.');
      });

      btnLimpar.addEventListener('click', () => { linesLayer.clearLayers(); pointsLayer.clearLayers(); logMsg('Pré-visualização removida.'); });
      btnProximo.addEventListener('click', () => {
        if (!polygons || polygons.length === 0) return;
        const next = (selectedIdx + 1) % polygons.length;
        selectPolygon(next, true);
      });

      btnGerar.addEventListener('click', () => {
        if (!polygonCoords || polygonCoords.length < 3) { logMsg('Selecione um talhão no mapa primeiro.', 'error'); return; }
        const spacing = Math.max(1, parseFloat(espEl.value || '40'));
        const angleDeg = Math.max(0, Math.min(179, parseFloat(angEl.value || '0')));
        const altitude = Math.max(0, parseFloat(altEl.value || '30'));
        const baseName = (selectedIdx>=0 && polygons[selectedIdx]?.name ? polygons[selectedIdx].name : 'Talhão');
        const prefix = (namePrefixEl.value || (baseName + ' ')).trim();
        const { pathLL, segmentsLL } = buildParallelPathInsidePolygon(polygonCoords, spacing, angleDeg, Math.max(0, parseFloat(borderEl.value || '0')));
        drawPath(pathLL);
        const kml = exportPathToKml(pathLL, altitude, prefix);
        const blob = new Blob([kml], { type: 'application/vnd.google-earth.kml+xml' });
        const url = URL.createObjectURL(blob);
        dlEl.href = url; dlEl.download = 'linhas-geradas.kml'; dlEl.style.display = 'inline-block';
        // Pontos opcional
        if (ptsToggleEl && ptsToggleEl.checked) {
          const spPts = Math.max(1, parseFloat(ptsSpacingEl.value || '30'));
          const pts = generatePointsAlongPath(pathLL, spPts);
          const kmlPts = exportPointsToKml(pts, altitude, prefix);
          const blobPts = new Blob([kmlPts], { type: 'application/vnd.google-earth.kml+xml' });
          const urlPts = URL.createObjectURL(blobPts);
          dlPtsEl.href = urlPts; dlPtsEl.download = 'pontos-gerados.kml'; dlPtsEl.style.display = 'inline-block';
        } else { dlPtsEl.style.display = 'none'; }
        addPathToProject(prefix || baseName, altitude, pathLL);
        updateExportLink();
        logMsg(`Caminho contínuo gerado para "${prefix || 'Talhão'}" com ${segmentsLL.length} faixas.`, 'success');
      });

      // Desenha todos os talhões e habilita clique para seleção
      function drawAllPolygons(items) {
        linesLayer.clearLayers();
        polyLayer.clearLayers();
        if (!items || items.length === 0) return;
        const defaultStyle = { color: '#34d399', weight: 2, fillOpacity: 0.15 };
        const selectedStyle = { color: '#f59e0b', weight: 3, fillOpacity: 0.25 };
        items.forEach((pg, idx) => {
          const latlngs = pg.coords.map(p => [p.lat, p.lon]);
          const poly = L.polygon(latlngs, defaultStyle).addTo(polyLayer);
          poly.bindTooltip((pg.name || `Talhão ${idx+1}`), {sticky: true});
          poly.on('click', () => selectPolygon(idx, true));
          pg._leaflet = poly;
        });
        // Se só existir um, seleciona automaticamente
        if (items.length === 1) selectPolygon(0, true);

        function applyStyles() {
          items.forEach((pg, i) => {
            if (!pg._leaflet) return;
            pg._leaflet.setStyle(i === selectedIdx ? selectedStyle : defaultStyle);
          });
        }
        // Guarda função para reuso em select
        drawAllPolygons.applyStyles = applyStyles;

        const bounds = L.latLngBounds(items.flatMap(pg => pg.coords.map(p => [p.lat, p.lon])));
        map.fitBounds(bounds.pad(0.2));
      }

      // Cria botão "Limpar Projeto" dinamicamente na barra de ações
      function createProjectControls() {
        const actions = document.querySelector('.actions');
        if (!actions) return;
        const b = document.createElement('button');
        b.id = 'btnLimparProjeto';
        b.className = 'secondary';
        b.textContent = 'Limpar Projeto';
        b.title = 'Remove todas as linhas já adicionadas ao projeto';
        b.disabled = true;
        actions.appendChild(b);
        btnLimparProjetoRef = b;
        b.addEventListener('click', () => {
          projectPaths = [];
          projectLayer.clearLayers();
          dlEl.style.display = 'none';
          b.disabled = true;
          logMsg('Projeto limpo.');
        });
      }

      function selectPolygon(idx, fit=false) {
        if (!polygons || idx < 0 || idx >= polygons.length) return;
        selectedIdx = idx;
        polygonCoords = polygons[idx].coords;
        btnGerar.disabled = false;
        linesLayer.clearLayers(); pointsLayer.clearLayers();
        if (drawAllPolygons.applyStyles) drawAllPolygons.applyStyles();
        if (fit) {
          const b = L.latLngBounds(polygonCoords.map(p => [p.lat, p.lon]));
          map.fitBounds(b.pad(0.15));
        }
        updatePreview();
        logMsg(`Talhão selecionado: ${(polygons[idx].name || 'Sem Nome')} (#${idx+1}).`);
      }

      // Desenha caminho contínuo
      function drawPath(pathLL) {
        linesLayer.clearLayers(); pointsLayer.clearLayers();
        if (!pathLL || pathLL.length < 2) return;
        L.polyline(pathLL.map(p => [p.lat, p.lon]), { color: '#60a5fa', weight: 3 }).addTo(linesLayer);
      }

      function drawPointsPreview(points) {
        pointsLayer.clearLayers();
        if (!points || points.length === 0) return;
        points.forEach((p, idx) => {
          const m = L.circleMarker([p.lat, p.lon], { radius: 4, color: '#22c55e', weight: 2, fillOpacity: 0.85 });
          m.bindTooltip(String(idx+1).padStart(3,'0'), { sticky: true });
          pointsLayer.addLayer(m);
        });
      }

      // Pré-visualização em tempo real (sem afetar o projeto)
      function updatePreview() {
        if (!polygonCoords || polygonCoords.length < 3) return;
        const spacing = Math.max(1, parseFloat(espEl.value || '40'));
        const angleDeg = Math.max(0, Math.min(179, parseFloat(angEl.value || '0')));
        const borderM = Math.max(0, parseFloat(borderEl.value || '0'));
        const { pathLL } = buildParallelPathInsidePolygon(polygonCoords, spacing, angleDeg, borderM);
        drawPath(pathLL);
        if (ptsToggleEl && ptsToggleEl.checked) {
          const spPts = Math.max(1, parseFloat(ptsSpacingEl.value || '30'));
          const pts = generatePointsAlongPath(pathLL, spPts);
          drawPointsPreview(pts);
        }
      }

      function addPathToProject(name, altitude, pathLL) {
        if (!pathLL || pathLL.length < 2) return;
        const idx = projectPaths.findIndex(p => p.name === name);
        if (idx >= 0) projectPaths.splice(idx, 1);
        projectPaths.push({ name, altitude, pathLL });
        // redesenha
        projectLayer.clearLayers();
        const colors = ['#f87171','#fb923c','#fbbf24','#34d399','#60a5fa','#a78bfa','#f472b6'];
        projectPaths.forEach((p, i) => {
          L.polyline(p.pathLL.map(pt => [pt.lat, pt.lon]), { color: colors[i % colors.length], weight: 3 })
            .addTo(projectLayer).bindTooltip(p.name, { sticky: true });
        });
        if (btnLimparProjetoRef) btnLimparProjetoRef.disabled = projectPaths.length === 0;
      }

      // Parse: extrai todos os polígonos (talhões) do KML, com nome do Placemark
      function extractPolygons(kmlText) {
        const out = [];
        try {
          const doc = new DOMParser().parseFromString(kmlText, 'text/xml');
          const placemarks = doc.getElementsByTagName('Placemark');
          const getText = (el, tag) => {
            const t = el.getElementsByTagName(tag)[0];
            return t ? (t.textContent || '').trim() : '';
          };
          for (let i = 0; i < placemarks.length; i++) {
            const pm = placemarks[i];
            const name = getText(pm, 'name') || `Talhão ${i+1}`;
            const polys = pm.getElementsByTagName('Polygon');
            for (let j = 0; j < polys.length; j++) {
              const poly = polys[j];
              const outer = poly.getElementsByTagName('outerBoundaryIs')[0] || poly;
              const lr = outer ? outer.getElementsByTagName('LinearRing')[0] : null;
              const coordsEl = (lr || poly).getElementsByTagName('coordinates')[0];
              if (!coordsEl) continue;
              const coords = parseCoordinates(coordsEl.textContent || '');
              if (coords.length >= 3) {
                let arr = coords.map(c => ({ lat: c.lat, lon: c.lon }));
                if (arr.length > 2) {
                  const f = arr[0], l = arr[arr.length-1];
                  if (Math.abs(f.lat - l.lat) < 1e-9 && Math.abs(f.lon - l.lon) < 1e-9) arr = arr.slice(1);
                }
                out.push({ name, coords: arr });
              }
            }
          }
        } catch (e) {}
        return out;
      }

      function parseCoordinates(text) {
        const tokens = (text || '').trim().split(/\s+/).filter(Boolean);
        const coords = [];
        for (const tok of tokens) {
          const parts = tok.split(',');
          if (parts.length >= 2) {
            const lon = parseFloat(parts[0]);
            const lat = parseFloat(parts[1]);
            const alt = parts.length >= 3 ? parseFloat(parts[2]) : 0;
            if (Number.isFinite(lon) && Number.isFinite(lat)) coords.push({ lon, lat, alt });
          }
        }
        return coords;
      }

      // Geometria: gerar linhas paralelas e caminho contínuo dentro do polígono
      function buildParallelPathInsidePolygon(polyLL, spacingMeters, angleDeg, marginMeters = 0) {
        // Converte para coordenadas projetadas (EPSG:3857) usando Leaflet
        const toM = (p) => L.CRS.EPSG3857.project(L.latLng(p.lat, p.lon));
        const toLL = (pt) => {
          const latlng = L.CRS.EPSG3857.unproject(L.point(pt.x, pt.y));
          return { lat: latlng.lat, lon: latlng.lng };
        };
        const polyM = polyLL.map(toM);

        // Direção d e normal n para o ângulo dado (0° = Leste, anti-horário)
        const theta = angleDeg * Math.PI / 180;
        const d = { x: Math.cos(theta), y: Math.sin(theta) };
        const n = { x: -Math.sin(theta), y: Math.cos(theta) };

        // Projeta vértices na normal para obter faixa de offsets que cobrem o polígono
        const dot = (a,b) => a.x*b.x + a.y*b.y;
        const projN = polyM.map(p => dot(p, n));
        let minOff = Math.min.apply(null, projN);
        let maxOff = Math.max.apply(null, projN);

        // Garante pelo menos 1 passo
        const step = Math.max(0.1, spacingMeters);
        const offsets = [];
        // Aplica bordadura lateral (afastamento em relação às bordas na normal)
        const lateral = Math.max(0, marginMeters || 0);
        const startOff = minOff + lateral;
        const endOff = maxOff - lateral;
        if (endOff - startOff >= step) {
          for (let off = startOff; off <= endOff + 1e-6; off += step) offsets.push(off);
        }

        // Função: interseção linha (dot(p,n)=off) com arestas do polígono
        const segments = [];
        for (const off of offsets) {
          const ints = [];
          for (let i = 0; i < polyM.length; i++) {
            const a = polyM[i];
            const b = polyM[(i+1) % polyM.length];
            const fa = dot(a, n) - off;
            const fb = dot(b, n) - off;
            if (Math.abs(fa) < 1e-9 && Math.abs(fb) < 1e-9) {
              // Aresta colinear com a linha: ignoramos para evitar duplicidades
              continue;
            }
            if ((fa <= 0 && fb >= 0) || (fa >= 0 && fb <= 0)) {
              const denom = fb - fa;
              if (Math.abs(denom) < 1e-12) continue;
              const t = (0 - fa) / denom; // fração ao longo de AB
              if (t >= 0 && t <= 1) {
                const x = a.x + (b.x - a.x) * t;
                const y = a.y + (b.y - a.y) * t;
                const pt = { x, y };
                const s = dot(pt, d); // parâmetro ao longo da direção
                ints.push({ pt, s });
              }
            }
          }
          if (ints.length < 2) continue;
          ints.sort((p, q) => p.s - q.s);
          for (let k = 0; k + 1 < ints.length; k += 2) {
            let p0 = ints[k].pt;
            let p1 = ints[k+1].pt;
            // Aplica bordadura nas extremidades do segmento (ao longo de d)
            const trim = Math.max(0, marginMeters || 0);
            if (trim > 0) {
              const vx = p1.x - p0.x, vy = p1.y - p0.y;
              const len = Math.hypot(vx, vy);
              if (len > 2*trim) {
                p0 = { x: p0.x + d.x * trim, y: p0.y + d.y * trim };
                p1 = { x: p1.x - d.x * trim, y: p1.y - d.y * trim };
              } else {
                continue; // segmento muito curto após bordadura
              }
            }
            segments.push({ a: p0, b: p1 });
          }
        }

        // Constrói caminho contínuo (boustrophedon) conectando segmentos com menor salto
        const segmentsLL = segments.map(seg => ({ a: toLL(seg.a), b: toLL(seg.b) }));
        const pathLL = [];
        if (segmentsLL.length > 0) {
          // Primeiro segmento: usa a->b
          pathLL.push(segmentsLL[0].a, segmentsLL[0].b);
          let prev = segmentsLL[0].b;
          const dist2 = (p, q) => {
            const dx = p.lon - q.lon; const dy = p.lat - q.lat; return dx*dx + dy*dy;
          };
          for (let i = 1; i < segmentsLL.length; i++) {
            const seg = segmentsLL[i];
            // Escolhe a extremidade mais próxima ao final anterior
            const da = dist2(prev, seg.a);
            const db = dist2(prev, seg.b);
            if (da <= db) {
              pathLL.push(seg.a, seg.b);
              prev = seg.b;
            } else {
              pathLL.push(seg.b, seg.a);
              prev = seg.a;
            }
          }
        }

        return { pathLL, segmentsLL };
      }

      // Gera pontos igualmente espaçados ao longo de um caminho (pathLL) em metros
      function generatePointsAlongPath(pathLL, spacingMeters) {
        try {
          const pts = [];
          if (!pathLL || pathLL.length < 2) return pts;
          const toM = (p) => L.CRS.EPSG3857.project(L.latLng(p.lat, p.lon));
          const toLL = (pt) => { const ll = L.CRS.EPSG3857.unproject(L.point(pt.x, pt.y)); return { lat: ll.lat, lon: ll.lng }; };
          const segs = [];
          let total = 0;
          for (let i = 0; i + 1 < pathLL.length; i++) {
            const aLL = pathLL[i], bLL = pathLL[i+1];
            const a = toM(aLL), b = toM(bLL);
            const len = Math.hypot(b.x - a.x, b.y - a.y);
            if (len > 0) { segs.push({ a, b, len }); total += len; }
          }
          const step = Math.max(0.1, Number(spacingMeters) || 1);
          if (total < step) return pts;
          for (let d = step; d <= total + 1e-6; d += step) {
            let acc = 0;
            for (let i=0; i<segs.length; i++) {
              const s = segs[i];
              if (d <= acc + s.len || i === segs.length - 1) {
                const t = Math.max(0, Math.min(1, (d - acc) / s.len));
                const x = s.a.x + (s.b.x - s.a.x) * t;
                const y = s.a.y + (s.b.y - s.a.y) * t;
                pts.push(toLL({ x, y }));
                break;
              }
              acc += s.len;
            }
          }
          return pts;
        } catch { return []; }
      }

      // Exporta caminho contínuo em KML (único LineString)
      /* function exportPathToKml(pathLL, altitude, prefix) {
        const esc = (s) => String(s == null ? '' : s).replace(/[&<>]/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
        let out = '';
        out += '<?xml version="1.0" encoding="UTF-8"?>\n';
        out += '<kml xmlns="http://www.opengis.net/kml/2.2">\n';
        out += '  <Document>\n';
        out += '    <name>Caminho Boustrophedon</name>\n';
        out += '    <Style id="lineStyle"><LineStyle><color>ff5fa8fa</color><width>3</width></LineStyle></Style>\n';
        const name = (prefix ? esc(prefix) : 'Missao ');
        out += '    <Placemark>\n';
        out += `      <name>${name}Caminho</name>\n`;
        out += '      <styleUrl>#lineStyle</styleUrl>\n';
        out += '      <LineString>\n';
        out += '        <tessellate>1</tessellate>\n';
        out += '        <altitudeMode>relativeToGround</altitudeMode>\n';
        out += '        <coordinates>\n';
        pathLL.forEach(p => {
          out += `          ${p.lon.toFixed(7)},${p.lat.toFixed(7)},${altitude}\
      // Gera e desenha pr�-visualiza��o sem afetar o projeto
      function updatePreview() {
        if (!polygonCoords || polygonCoords.length < 3) return;
        const spacing = Math.max(1, parseFloat(espEl.value || '40'));
        const angleDeg = Math.max(0, Math.min(179, parseFloat(angEl.value || '0')));
        const { pathLL } = buildParallelPathInsidePolygon(polygonCoords, spacing, angleDeg, Math.max(0, parseFloat(borderEl.value || '0')));
        drawPath(pathLL);
      }n`;
        });
        out += '        </coordinates>\n';
        out += '      </LineString>\n';
        out += '    </Placemark>\n';
        out += '  </Document>\n';
        out += '</kml>\n';
        return out;
      }
      */

      // Nova implementação correta de exportação KML para o caminho atual
      function exportPathToKml(pathLL, altitude, prefix) {
        const esc = (s) => String(s == null ? '' : s).replace(/[&<>]/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
        let out = '';
        out += '<?xml version="1.0" encoding="UTF-8"?>\n';
        out += '<kml xmlns="http://www.opengis.net/kml/2.2">\n';
        out += '  <Document>\n';
        out += '    <name>Caminho Boustrophedon</name>\n';
        out += '    <Style id="lineStyle"><LineStyle><color>ff5fa8fa</color><width>3</width></LineStyle></Style>\n';
        const name = (prefix ? esc(prefix) : 'Missao ');
        out += '    <Placemark>\n';
        out += `      <name>${name}Caminho</name>\n`;
        out += '      <styleUrl>#lineStyle</styleUrl>\n';
        out += '      <LineString>\n';
        out += '        <tessellate>1</tessellate>\n';
        out += '        <altitudeMode>relativeToGround</altitudeMode>\n';
        out += '        <coordinates>\n';
        pathLL.forEach(p => { out += `          ${p.lon.toFixed(7)},${p.lat.toFixed(7)},${altitude}\n`; });
        out += '        </coordinates>\n';
        out += '      </LineString>\n';
        out += '    </Placemark>\n';
        out += '  </Document>\n';
        out += '</kml>\n';
        return out;
      }

      function exportProjectToKml(items) {
        const esc = (s) => String(s == null ? '' : s).replace(/[&<>]/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
        let out = '';
        out += '<?xml version="1.0" encoding="UTF-8"?>\n';
        out += '<kml xmlns="http://www.opengis.net/kml/2.2">\n';
        out += '  <Document>\n';
        out += '    <name>Projeto Linhas</name>\n';
        out += '    <Style id="lineStyle"><LineStyle><color>ff5fa8fa</color><width>3</width></LineStyle></Style>\n';
        items.forEach((it) => {
          out += '    <Placemark>\n';
          out += `      <name>${esc(it.name || 'Talhao')}</name>\n`;
          out += '      <styleUrl>#lineStyle</styleUrl>\n';
          out += '      <LineString>\n';
          out += '        <tessellate>1</tessellate>\n';
          out += '        <altitudeMode>relativeToGround</altitudeMode>\n';
          out += '        <coordinates>\n';
          it.pathLL.forEach(p => { out += `          ${p.lon.toFixed(7)},${p.lat.toFixed(7)},${it.altitude|0}\n`; });
          out += '        </coordinates>\n';
          out += '      </LineString>\n';
          out += '    </Placemark>\n';
        });
        out += '  </Document>\n';
        out += '</kml>\n';
        return out;
      }

      function updateExportLink() {
        if (!projectPaths || projectPaths.length === 0) { dlEl.style.display = 'none'; return; }
        const kml = exportProjectToKml(projectPaths);
        const blob = new Blob([kml], { type: 'application/vnd.google-earth.kml+xml' });
        const url = URL.createObjectURL(blob);
        dlEl.href = url; dlEl.download = 'projeto-linhas.kml'; dlEl.style.display = 'inline-block';
      }

      function exportPointsToKml(pointsLL, altitude, prefix) {
        const esc = (s) => String(s == null ? '' : s).replace(/[&<>]/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
        let out = '';
        out += '<?xml version="1.0" encoding="UTF-8"?>\n';
        out += '<kml xmlns="http://www.opengis.net/kml/2.2">\n';
        out += '  <Document>\n';
        out += `    <name>${esc(prefix || 'Pontos')}</name>\n`;
        out += '    <Style id="ptStyle"><IconStyle><color>ff22c55e</color><scale>1.1</scale><Icon><href>http://maps.google.com/mapfiles/kml/paddle/grn-circle.png</href></Icon></IconStyle></Style>\n';
        out += '    <Folder>\n';
        out += '      <name>Pontos Gerados</name>\n';
        pointsLL.forEach((p, i) => {
          const nm = String(i+1).padStart(3, '0');
          out += '      <Placemark>\n';
          out += `        <name>${esc((prefix||'') + nm)}</name>\n`;
          out += '        <styleUrl>#ptStyle</styleUrl>\n';
          out += '        <Point>\n';
          out += '          <altitudeMode>relativeToGround</altitudeMode>\n';
          out += `          <coordinates>${p.lon.toFixed(7)},${p.lat.toFixed(7)},${altitude|0}</coordinates>\n`;
          out += '        </Point>\n';
          out += '      </Placemark>\n';
        });
        out += '    </Folder>\n';
        out += '  </Document>\n';
        out += '</kml>\n';
        return out;
      }
    </script>
  </body>
</html>







