<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Criar Linhas Paralelas dentro de Pol√≠gono (KML)</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <style>
      :root {
        --bg: #0f172a; --panel: #111827; --soft: #1f2937; --text: #e5e7eb;
        --muted: #9ca3af; --accent: #60a5fa; --danger: #ef4444;
      }
      html, body { margin: 0; padding: 0; height: 100%; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif; background: var(--bg); color: var(--text); }
      .wrap { max-width: 1000px; margin: 24px auto; padding: 0 16px; }
      .card { background: var(--panel); border: 1px solid #1f2937; border-radius: 10px; padding: 20px; }
      h1 { font-size: 1.4rem; margin: 0 0 12px; }
      p.helper { color: var(--muted); margin-top: 4px; font-size: .95rem; }
      .row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-top: 12px; }
      .row.single { grid-template-columns: 1fr; }
      .field { display: flex; flex-direction: column; gap: 6px; }
      label { color: var(--muted); font-size: .9rem; }
      input[type="number"], input[type="text"], input[type="file"], input[type="range"], select { border: 1px solid #374151; background: var(--soft); color: var(--text); border-radius: 8px; padding: 10px; font-size: 1rem; }
      input[type="range"] { padding: 6px 0; }
      button { background: var(--accent); color: #0b1220; border: none; padding: 10px 14px; border-radius: 8px; font-weight: 600; cursor: pointer; }
      button.secondary { background: #374151; color: var(--text); }
      button:disabled { opacity: .6; cursor: not-allowed; }
      .actions { display: flex; gap: 10px; align-items: center; margin-top: 16px; flex-wrap: wrap; }
      .log { margin-top: 16px; background: #0b1220; border: 1px solid #1f2937; padding: 12px; border-radius: 8px; white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: .9rem; color: #cbd5e1; }
      .success { color: #22c55e; }
      .error { color: var(--danger); }
      .hint { color: var(--muted); font-size: .9rem; }
      .footer { margin-top: 24px; color: var(--muted); font-size: .85rem; text-align: center; }
      a { color: #93c5fd; }
      #map { height: 62vh; width: 100%; margin-top: 16px; border-radius: 10px; border: 1px solid #1f2937; }
      .angle-value { min-width: 60px; text-align: right; }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="card">
        <h1>Criar Linhas Paralelas dentro de Pol√≠gono (KML)</h1>
        <p class="helper">Carregue um KML com a √°rea demarcada (<code>&lt;Polygon&gt;</code>). Ajuste espa√ßamento entre linhas (m), √¢ngulo (¬∞) e altitude (m). Gere linhas paralelas "indo e voltando" dentro do pol√≠gono e exporte em KML. Base de sat√©lite inclu√≠da para melhor visualiza√ß√£o.</p>

        <div class="row single">
          <div class="field">
            <label for="kmlFile">Arquivo KML com Talh√µes (Pol√≠gonos)</label>
            <input id="kmlFile" type="file" accept=".kml,application/vnd.google-earth.kml+xml" />
            <div class="hint">O arquivo pode conter v√°rios <code>&lt;Polygon&gt;</code>. Clique no talh√£o desejado no mapa para selecion√°-lo.</div>
          </div>
        </div>

        <div class="row">
          <div class="field">
            <label for="espacamento">Espa√ßamento entre linhas (m)</label>
            <input id="espacamento" type="number" min="1" step="1" value="40" />
          </div>
          <div class="field">
            <label for="angulo">√Çngulo das linhas (¬∞)</label>
            <div style="display:flex; align-items:center; gap:10px;">
              <input id="angulo" type="range" min="0" max="179" step="1" value="0" style="flex:1;" />
              <input id="anguloBox" type="number" min="0" max="179" step="1" value="0" class="angle-value" />
            </div>
            <div class="hint">0¬∞ = Leste-Oeste; aumenta no sentido anti-hor√°rio.</div>
          </div>
        </div>

        <div class="row">
          <div class="field">
            <label for="altura">Altitude das linhas (m)</label>
            <input id="altura" type="number" min="0" step="1" value="30" />
          </div>
          <div class="field">
            <label for="nomePrefixo">Prefixo do nome (opcional)</label>
            <input id="nomePrefixo" type="text" placeholder="Ex.: FAIXA-" />
          </div>
        </div>

        <div class="actions">
          <button id="btnGerar" disabled>Gerar Linhas</button>
          <a id="downloadLink" class="secondary" href="#" download style="display:none;">Exportar Projeto (KML)</a>
          <button id="btnExemplo" class="secondary" title="Carrega um pol√≠gono de exemplo">Carregar Exemplo</button>
          <button id="btnLimpar" class="secondary">Limpar Linhas</button>
          <button id="btnProximo" class="secondary" title="Seleciona o pr√≥ximo talh√£o" disabled>Pr√≥ximo Talh√£o</button>
        </div>

        <div id="map"></div>
        <div id="log" class="log hint">Carregue um KML de pol√≠gono para come√ßar.</div>
      </div>
      <div class="footer">Base sat√©lite: Esri World Imagery ‚Ä¢ Mapas por Leaflet</div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script>
      // Estado global simples
      let polygonCoords = null; // Array [{lat,lon}] do outer ring (selecionado)
      let polygons = []; // Lista de talh√µes [{coords, name}]
      let selectedIdx = -1;
      let polyLayer = null; // LayerGroup com todos os talh√µes
      let linesLayer = null;
      let projectLayer = null; // Linhas acumuladas do projeto
      let projectPaths = [];
      let btnLimparProjetoRef = null; // criado dinamicamente
      let map = null;

      // Helpers de UI
      const logEl = document.getElementById('log');
      const kmlFileEl = document.getElementById('kmlFile');
      const espEl = document.getElementById('espacamento');
      const angEl = document.getElementById('angulo');
      const angBoxEl = document.getElementById('anguloBox');
      const altEl = document.getElementById('altura');
      const namePrefixEl = document.getElementById('nomePrefixo');
      const btnGerar = document.getElementById('btnGerar');
      const dlEl = document.getElementById('downloadLink');
      const btnExemplo = document.getElementById('btnExemplo');
      const btnLimpar = document.getElementById('btnLimpar');
      const btnProximo = document.getElementById('btnProximo');
      // Bot√£o 'Limpar Projeto' ser√° criado dinamicamente

      function logMsg(msg, type='hint') {
        logEl.className = 'log ' + (type === 'error' ? 'error' : type === 'success' ? 'success' : 'hint');
        logEl.textContent = msg;
      }

      // Inicializa mapa com base de sat√©lite
      function initMap() {
        map = L.map('map', { zoomControl: true }).setView([-15.78, -47.93], 5); // Brasil
        const esriSat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
          maxZoom: 20,
          attribution: 'Tiles \u00a9 Esri'
        }).addTo(map);
        const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: 'OSM' });
        L.control.layers({ 'Sat√©lite (Esri)': esriSat, 'Ruas (OSM)': osm }).addTo(map);
        polyLayer = L.layerGroup().addTo(map);
        projectLayer = L.layerGroup().addTo(map);
        linesLayer = L.layerGroup().addTo(map);
      }

      initMap();
      createProjectControls();

      // Sincroniza slider/box de √¢ngulo
      angEl.addEventListener('input', () => { angBoxEl.value = angEl.value; updatePreview(); });
      angBoxEl.addEventListener('input', () => {
        let v = parseInt(angBoxEl.value || '0', 10);
        if (!Number.isFinite(v)) v = 0;
        if (v < 0) v = 0; if (v > 179) v = 179;
        angBoxEl.value = v; angEl.value = v; updatePreview();
      });
      // Atualiza pr√©-visualiza√ß√£o ao mudar espa√ßamento
      espEl.addEventListener('input', () => { updatePreview(); });

      // Leitura e parse de KML (m√∫ltiplos pol√≠gonos)
      kmlFileEl.addEventListener('change', async (e) => {
        const f = e.target.files && e.target.files[0];
        if (!f) return;
        const text = await f.text();
        const res = extractPolygons(text);
        if (!res || res.length === 0) { logMsg('Nenhum pol√≠gono v√°lido encontrado no KML.', 'error'); btnGerar.disabled = true; btnProximo.disabled = true; return; }
        polygons = res; selectedIdx = -1; polygonCoords = null; btnGerar.disabled = true; btnProximo.disabled = (polygons.length <= 1); dlEl.style.display = 'none';
        drawAllPolygons(polygons);
        const totalVerts = polygons.reduce((s,p)=>s+p.coords.length,0);
        logMsg(`Carregados ${polygons.length} talh√£o(√µes), ${totalVerts} v√©rtices no total. Clique em um talh√£o para selecionar.`);
      });

      btnExemplo.addEventListener('click', () => {
        const sample = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <Placemark>
      <name>Talh√£o 01</name>
      <Polygon>
        <outerBoundaryIs>
          <LinearRing>
            <coordinates>
              -47.9400,-15.8100,0 -47.9000,-15.8100,0 -47.9000,-15.7800,0 -47.9400,-15.7800,0 -47.9400,-15.8100,0
            </coordinates>
          </LinearRing>
        </outerBoundaryIs>
      </Polygon>
    </Placemark>
    <Placemark>
      <name>Talh√£o 02</name>
      <Polygon>
        <outerBoundaryIs>
          <LinearRing>
            <coordinates>
              -47.9850,-15.8150,0 -47.9550,-15.8150,0 -47.9550,-15.7900,0 -47.9850,-15.7900,0 -47.9850,-15.8150,0
            </coordinates>
          </LinearRing>
        </outerBoundaryIs>
      </Polygon>
    </Placemark>
  </Document>
</kml>`;
        polygons = extractPolygons(sample);
        selectedIdx = -1; polygonCoords = null; btnGerar.disabled = true; btnProximo.disabled = (polygons.length <= 1); dlEl.style.display = 'none';
        drawAllPolygons(polygons);
        const bounds = L.latLngBounds(polygons.flatMap(pg => pg.coords.map(p => [p.lat, p.lon])));
        map.fitBounds(bounds.pad(0.2));
        logMsg('Exemplo com 2 talh√µes carregado. Clique para selecionar.');
      });

      btnLimpar.addEventListener('click', () => { linesLayer.clearLayers(); logMsg('Pr√©-visualiza√ß√£o removida.'); });
      btnProximo.addEventListener('click', () => {
        if (!polygons || polygons.length === 0) return;
        const next = (selectedIdx + 1) % polygons.length;
        selectPolygon(next, true);
      });

      btnGerar.addEventListener('click', () => {
        if (!polygonCoords || polygonCoords.length < 3) { logMsg('Selecione um talh√£o no mapa primeiro.', 'error'); return; }
        const spacing = Math.max(1, parseFloat(espEl.value || '40'));
        const angleDeg = Math.max(0, Math.min(179, parseFloat(angEl.value || '0')));
        const altitude = Math.max(0, parseFloat(altEl.value || '30'));
        const baseName = (selectedIdx>=0 && polygons[selectedIdx]?.name ? polygons[selectedIdx].name : 'Talh√£o');
        const prefix = (namePrefixEl.value || (baseName + ' ')).trim();
        const { pathLL, segmentsLL } = buildParallelPathInsidePolygon(polygonCoords, spacing, angleDeg);
        drawPath(pathLL);
        const kml = exportPathToKml(pathLL, altitude, prefix);
        const blob = new Blob([kml], { type: 'application/vnd.google-earth.kml+xml' });
        const url = URL.createObjectURL(blob);
        dlEl.href = url; dlEl.download = 'linhas-geradas.kml'; dlEl.style.display = 'inline-block';
        addPathToProject(prefix || baseName, altitude, pathLL);
        updateExportLink();
        logMsg(`Caminho cont√≠nuo gerado para "${prefix || 'Talh√£o'}" com ${segmentsLL.length} faixas.`, 'success');
      });

      // Desenha todos os talh√µes e habilita clique para sele√ß√£o
      function drawAllPolygons(items) {
        linesLayer.clearLayers();
        polyLayer.clearLayers();
        if (!items || items.length === 0) return;
        const defaultStyle = { color: '#34d399', weight: 2, fillOpacity: 0.15 };
        const selectedStyle = { color: '#f59e0b', weight: 3, fillOpacity: 0.25 };
        items.forEach((pg, idx) => {
          const latlngs = pg.coords.map(p => [p.lat, p.lon]);
          const poly = L.polygon(latlngs, defaultStyle).addTo(polyLayer);
          poly.bindTooltip((pg.name || `Talh√£o ${idx+1}`), {sticky: true});
          poly.on('click', () => selectPolygon(idx, true));
          pg._leaflet = poly;
        });
        // Se s√≥ existir um, seleciona automaticamente
        if (items.length === 1) selectPolygon(0, true);

        function applyStyles() {
          items.forEach((pg, i) => {
            if (!pg._leaflet) return;
            pg._leaflet.setStyle(i === selectedIdx ? selectedStyle : defaultStyle);
          });
        }
        // Guarda fun√ß√£o para reuso em select
        drawAllPolygons.applyStyles = applyStyles;

        const bounds = L.latLngBounds(items.flatMap(pg => pg.coords.map(p => [p.lat, p.lon])));
        map.fitBounds(bounds.pad(0.2));
      }

      // Cria bot√£o "Limpar Projeto" dinamicamente na barra de a√ß√µes
      function createProjectControls() {
        const actions = document.querySelector('.actions');
        if (!actions) return;
        const b = document.createElement('button');
        b.id = 'btnLimparProjeto';
        b.className = 'secondary';
        b.textContent = 'Limpar Projeto';
        b.title = 'Remove todas as linhas j√° adicionadas ao projeto';
        b.disabled = true;
        actions.appendChild(b);
        btnLimparProjetoRef = b;
        b.addEventListener('click', () => {
          projectPaths = [];
          projectLayer.clearLayers();
          dlEl.style.display = 'none';
          b.disabled = true;
          logMsg('Projeto limpo.');
        });
      }

      function selectPolygon(idx, fit=false) {
        if (!polygons || idx < 0 || idx >= polygons.length) return;
        selectedIdx = idx;
        polygonCoords = polygons[idx].coords;
        btnGerar.disabled = false;
        linesLayer.clearLayers();
        if (drawAllPolygons.applyStyles) drawAllPolygons.applyStyles();
        if (fit) {
          const b = L.latLngBounds(polygonCoords.map(p => [p.lat, p.lon]));
          map.fitBounds(b.pad(0.15));
        }
        logMsg(`Talh√£o selecionado: ${(polygons[idx].name || 'Sem Nome')} (#${idx+1}).`);
      }

      // Desenha caminho cont√≠nuo
      function drawPath(pathLL) {
        linesLayer.clearLayers();
        if (!pathLL || pathLL.length < 2) return;
        L.polyline(pathLL.map(p => [p.lat, p.lon]), { color: '#60a5fa', weight: 3 }).addTo(linesLayer);
      }

      function addPathToProject(name, altitude, pathLL) {
        if (!pathLL || pathLL.length < 2) return;
        const idx = projectPaths.findIndex(p => p.name === name);
        if (idx >= 0) projectPaths.splice(idx, 1);
        projectPaths.push({ name, altitude, pathLL });
        // redesenha
        projectLayer.clearLayers();
        const colors = ['#f87171','#fb923c','#fbbf24','#34d399','#60a5fa','#a78bfa','#f472b6'];
        projectPaths.forEach((p, i) => {
          L.polyline(p.pathLL.map(pt => [pt.lat, pt.lon]), { color: colors[i % colors.length], weight: 3 })
            .addTo(projectLayer).bindTooltip(p.name, { sticky: true });
        });
        if (btnLimparProjetoRef) btnLimparProjetoRef.disabled = projectPaths.length === 0;
      }

      // Parse: extrai todos os pol√≠gonos (talh√µes) do KML, com nome do Placemark
      function extractPolygons(kmlText) {
        const out = [];
        try {
          const doc = new DOMParser().parseFromString(kmlText, 'text/xml');
          const placemarks = doc.getElementsByTagName('Placemark');
          const getText = (el, tag) => {
            const t = el.getElementsByTagName(tag)[0];
            return t ? (t.textContent || '').trim() : '';
          };
          for (let i = 0; i < placemarks.length; i++) {
            const pm = placemarks[i];
            const name = getText(pm, 'name') || `Talh√£o ${i+1}`;
            const polys = pm.getElementsByTagName('Polygon');
            for (let j = 0; j < polys.length; j++) {
              const poly = polys[j];
              const outer = poly.getElementsByTagName('outerBoundaryIs')[0] || poly;
              const lr = outer ? outer.getElementsByTagName('LinearRing')[0] : null;
              const coordsEl = (lr || poly).getElementsByTagName('coordinates')[0];
              if (!coordsEl) continue;
              const coords = parseCoordinates(coordsEl.textContent || '');
              if (coords.length >= 3) {
                let arr = coords.map(c => ({ lat: c.lat, lon: c.lon }));
                if (arr.length > 2) {
                  const f = arr[0], l = arr[arr.length-1];
                  if (Math.abs(f.lat - l.lat) < 1e-9 && Math.abs(f.lon - l.lon) < 1e-9) arr = arr.slice(1);
                }
                out.push({ name, coords: arr });
              }
            }
          }
        } catch (e) {}
        return out;
      }

      function parseCoordinates(text) {
        const tokens = (text || '').trim().split(/\s+/).filter(Boolean);
        const coords = [];
        for (const tok of tokens) {
          const parts = tok.split(',');
          if (parts.length >= 2) {
            const lon = parseFloat(parts[0]);
            const lat = parseFloat(parts[1]);
            const alt = parts.length >= 3 ? parseFloat(parts[2]) : 0;
            if (Number.isFinite(lon) && Number.isFinite(lat)) coords.push({ lon, lat, alt });
          }
        }
        return coords;
      }

      // Geometria: gerar linhas paralelas e caminho cont√≠nuo dentro do pol√≠gono
      function buildParallelPathInsidePolygon(polyLL, spacingMeters, angleDeg) {
        // Converte para coordenadas projetadas (EPSG:3857) usando Leaflet
        const toM = (p) => L.CRS.EPSG3857.project(L.latLng(p.lat, p.lon));
        const toLL = (pt) => {
          const latlng = L.CRS.EPSG3857.unproject(L.point(pt.x, pt.y));
          return { lat: latlng.lat, lon: latlng.lng };
        };
        const polyM = polyLL.map(toM);

        // Dire√ß√£o d e normal n para o √¢ngulo dado (0¬∞ = Leste, anti-hor√°rio)
        const theta = angleDeg * Math.PI / 180;
        const d = { x: Math.cos(theta), y: Math.sin(theta) };
        const n = { x: -Math.sin(theta), y: Math.cos(theta) };

        // Projeta v√©rtices na normal para obter faixa de offsets que cobrem o pol√≠gono
        const dot = (a,b) => a.x*b.x + a.y*b.y;
        const projN = polyM.map(p => dot(p, n));
        let minOff = Math.min.apply(null, projN);
        let maxOff = Math.max.apply(null, projN);

        // Garante pelo menos 1 passo
        const step = Math.max(0.1, spacingMeters);
        const offsets = [];
        // Expande pequena margem para garantir cobertura total
        minOff -= step; maxOff += step;
        for (let off = minOff; off <= maxOff + 1e-6; off += step) offsets.push(off);

        // Fun√ß√£o: interse√ß√£o linha (dot(p,n)=off) com arestas do pol√≠gono
        const segments = [];
        for (const off of offsets) {
          const ints = [];
          for (let i = 0; i < polyM.length; i++) {
            const a = polyM[i];
            const b = polyM[(i+1) % polyM.length];
            const fa = dot(a, n) - off;
            const fb = dot(b, n) - off;
            if (Math.abs(fa) < 1e-9 && Math.abs(fb) < 1e-9) {
              // Aresta colinear com a linha: ignoramos para evitar duplicidades
              continue;
            }
            if ((fa <= 0 && fb >= 0) || (fa >= 0 && fb <= 0)) {
              const denom = fb - fa;
              if (Math.abs(denom) < 1e-12) continue;
              const t = (0 - fa) / denom; // fra√ß√£o ao longo de AB
              if (t >= 0 && t <= 1) {
                const x = a.x + (b.x - a.x) * t;
                const y = a.y + (b.y - a.y) * t;
                const pt = { x, y };
                const s = dot(pt, d); // par√¢metro ao longo da dire√ß√£o
                ints.push({ pt, s });
              }
            }
          }
          if (ints.length < 2) continue;
          ints.sort((p, q) => p.s - q.s);
          for (let k = 0; k + 1 < ints.length; k += 2) {
            const p0 = ints[k].pt;
            const p1 = ints[k+1].pt;
            segments.push({ a: p0, b: p1 });
          }
        }

        // Constr√≥i caminho cont√≠nuo (boustrophedon) conectando segmentos com menor salto
        const segmentsLL = segments.map(seg => ({ a: toLL(seg.a), b: toLL(seg.b) }));
        const pathLL = [];
        if (segmentsLL.length > 0) {
          // Primeiro segmento: usa a->b
          pathLL.push(segmentsLL[0].a, segmentsLL[0].b);
          let prev = segmentsLL[0].b;
          const dist2 = (p, q) => {
            const dx = p.lon - q.lon; const dy = p.lat - q.lat; return dx*dx + dy*dy;
          };
          for (let i = 1; i < segmentsLL.length; i++) {
            const seg = segmentsLL[i];
            // Escolhe a extremidade mais pr√≥xima ao final anterior
            const da = dist2(prev, seg.a);
            const db = dist2(prev, seg.b);
            if (da <= db) {
              pathLL.push(seg.a, seg.b);
              prev = seg.b;
            } else {
              pathLL.push(seg.b, seg.a);
              prev = seg.a;
            }
          }
        }

        return { pathLL, segmentsLL };
      }

      // Exporta caminho cont√≠nuo em KML (√∫nico LineString)
      function exportPathToKml(pathLL, altitude, prefix) {
        const esc = (s) => String(s == null ? '' : s).replace(/[&<>]/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
        let out = '';
        out += '<?xml version="1.0" encoding="UTF-8"?>\n';
        out += '<kml xmlns="http://www.opengis.net/kml/2.2">\n';
        out += '  <Document>\n';
        out += '    <name>Caminho Boustrophedon</name>\n';
        out += '    <Style id="lineStyle"><LineStyle><color>ff5fa8fa</color><width>3</width></LineStyle></Style>\n';
        const name = (prefix ? esc(prefix) : 'Missao ');
        out += '    <Placemark>\n';
        out += `      <name>${name}Caminho</name>\n`;
        out += '      <styleUrl>#lineStyle</styleUrl>\n';
        out += '      <LineString>\n';
        out += '        <tessellate>1</tessellate>\n';
        out += '        <altitudeMode>relativeToGround</altitudeMode>\n';
        out += '        <coordinates>\n';
        pathLL.forEach(p => {
          out += `          ${p.lon.toFixed(7)},${p.lat.toFixed(7)},${altitude}\
      // Gera e desenha prÈ-visualizaÁ„o sem afetar o projeto
      function updatePreview() {
        if (!polygonCoords || polygonCoords.length < 3) return;
        const spacing = Math.max(1, parseFloat(espEl.value || '40'));
        const angleDeg = Math.max(0, Math.min(179, parseFloat(angEl.value || '0')));
        const { pathLL } = buildParallelPathInsidePolygon(polygonCoords, spacing, angleDeg);
        drawPath(pathLL);
      }n`;
        });
        out += '        </coordinates>\n';
        out += '      </LineString>\n';
        out += '    </Placemark>\n';
        out += '  </Document>\n';
        out += '</kml>\n';
        return out;
      }
      function exportProjectToKml(items) {
        const esc = (s) => String(s == null ? '' : s).replace(/[&<>]/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
        let out = '';
        out += '<?xml version="1.0" encoding="UTF-8"?>\n';
        out += '<kml xmlns="http://www.opengis.net/kml/2.2">\n';
        out += '  <Document>\n';
        out += '    <name>Projeto Linhas</name>\n';
        out += '    <Style id="lineStyle"><LineStyle><color>ff5fa8fa</color><width>3</width></LineStyle></Style>\n';
        items.forEach((it) => {
          out += '    <Placemark>\n';
          out += `      <name>${esc(it.name || 'Talhao')}</name>\n`;
          out += '      <styleUrl>#lineStyle</styleUrl>\n';
          out += '      <LineString>\n';
          out += '        <tessellate>1</tessellate>\n';
          out += '        <altitudeMode>relativeToGround</altitudeMode>\n';
          out += '        <coordinates>\n';
          it.pathLL.forEach(p => { out += `          ${p.lon.toFixed(7)},${p.lat.toFixed(7)},${it.altitude|0}\n`; });
          out += '        </coordinates>\n';
          out += '      </LineString>\n';
          out += '    </Placemark>\n';
        });
        out += '  </Document>\n';
        out += '</kml>\n';
        return out;
      }

      function updateExportLink() {
        if (!projectPaths || projectPaths.length === 0) { dlEl.style.display = 'none'; return; }
        const kml = exportProjectToKml(projectPaths);
        const blob = new Blob([kml], { type: 'application/vnd.google-earth.kml+xml' });
        const url = URL.createObjectURL(blob);
        dlEl.href = url; dlEl.download = 'projeto-linhas.kml'; dlEl.style.display = 'inline-block';
      }
    </script>
  </body>
</html>


